#version 460

struct light_t 
{
    vec3 pos;
    vec3 color;
};

struct encoded_light_t 
{
    uint morton_code;
    uint index;
};

layout(std430, set = 0, binding = 0) readonly buffer lights_buffer
{
    light_t lights[];
};

layout(std430, set = 0, binding = 1) writeonly buffer out_buffer
{
    encoded_light_t encoded_lights[];
};

layout(push_constant) uniform constants
{
    int num_lights;
};

//https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
uvec3 part1by2(uvec3 x)
{
    x &= 0x000003ff;
    x = (x ^ (x << 16)) & 0xff0000ff;
    x = (x ^ (x << 8)) & 0x0300f00f;
    x = (x ^ (x << 4)) & 0x030c30c3;
    x = (x ^ (x << 2)) & 0x09249249;
    return x;
}

//https://developer.nvidia.com/blog/thinking-parallel-part-iii-tree-construction-gpu/
uvec3 bit_expansion(uvec3 x)
{
    x = (x * 0x00010001u) & 0xff0000ffu;
    x = (x * 0x00000101u) & 0x0f00f00fu;
    x = (x * 0x00000011u) & 0xc30c30c3u;
    x = (x * 0x00000005u) & 0x49249249u;
    return x;
}

uint encode_morton(vec3 v)
{
    v = min(max(normalize(v)*1024.0f, 0.0f), 1023.0f);
    uvec3 bits = bit_expansion(uvec3(v));
    return (bits.z << 2) + (bits.y << 1) + bits.x;
}

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uint i = gl_GlobalInvocationID.x;
    if (i < num_lights)
    {
        encoded_lights[i].morton_code = encode_morton(lights[i].pos);
        encoded_lights[i].index = i;
    }
}


