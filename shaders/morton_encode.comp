#version 460

struct light_t 
{
    vec3 pos;
    vec3 color;
};

struct encoded_light_t 
{
    uint morton_code;
    uint index;
};

layout(set = 0, binding = 0) readonly buffer lights_buffer
{
    light_t lights[];
};

layout(set = 0, binding = 1) writeonly buffer out_buffer
{
    encoded_light_t encoded_lights[];
};

layout(push_constant) uniform constants
{
    int num_lights;
};

// taken from https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
uvec3 part1by2(uvec3 x)
{
    x &= 0x000003ff;
    x = (x ^ (x << 16)) & 0xff0000ff;
    x = (x ^ (x << 8)) & 0x0300f00f;
    x = (x ^ (x << 4)) & 0x030c30c3;
    x = (x ^ (x << 2)) & 0x09249249;
    return x;
}

uint encode_morton(vec3 v)
{
   uvec3 bits = part1by2(uvec3(v));
   return (bits.z << 2) + (bits.y << 1) + bits.x;
}

layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;
void main()
{
    //uint i = gl_GlobalInvocationID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    uint i = gl_GlobalInvocationID.x;
    if (i < num_lights)
    {
        vec3 pos = lights[i].pos;
        encoded_lights[i].morton_code = encode_morton(pos);
        encoded_lights[i].index = i;
    }
}


