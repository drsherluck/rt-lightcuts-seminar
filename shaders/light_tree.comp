#version 460
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct light_t 
{
    vec3 pos;
    vec3 color;
};

struct encoded_light_t 
{
    uint32_t morton_code;
    uint32_t index;
};

struct node_t // 32 bytes
{
    vec3 aabb_min; // alignment = 16
    float intensity;
    vec3 aabb_max;
    uint id;
}; 

layout(std430, set = 0, binding = 0) readonly buffer lights_buffer
{
    light_t lights[];
};

layout(std430, set = 0, binding = 1) readonly buffer encoded_buffer
{
    encoded_light_t encoded_lights[];
};

layout(std430, set = 0, binding = 2) writeonly buffer tree_buffer
{
    node_t nodes[]; // 2^(h+1) - 1 nodes (h is amount levels)
};

void main()
{
    uint level = gl_GlobalInvocationID.x;
    uint tree_height = gl_NumWorkGroups.x - 1;
    uint node_count  = 1 << level;
    uint nodes_below = (1 << (tree_height + 1)) - (1 << (level + 1));
    uint merge_count = 1 << (tree_height - level);
    
    for (uint i = 0; i < node_count; i++)
    {
        uint index = i + nodes_below;
        nodes[index].id = index;
        nodes[index].intensity = 0;
        //nodes[index].aabb_min  = vec3(0);
        //nodes[index].aabb_max  = vec3(0);

        uint skip = i * merge_count;
        for (uint k = 0; k < merge_count; k++)
        {
            light_t light = lights[encoded_lights[k + skip].index];
            if (light.color != vec3(0)) // bogus lights skipped 
            {
                nodes[index].intensity += 1.0;
                //nodes[index].aabb_min += vec3(-1000.0);//light.aabb_min;
                //nodes[index].aabb_max += vec3(1000.0);//light.aabb_max;
            }
        }
    }
}


